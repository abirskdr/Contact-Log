{"ast":null,"code":"var _jsxFileName = \"D:\\\\Resume Projects\\\\Contact-log\\\\src\\\\store\\\\favorites-context.js\",\n    _s = $RefreshSig$();\n\n// import { createContext, useState } from 'react';\n// //\"createContext()\" creates a context\n// //context is a JS object, this object created by CreateContext actually contains a react component\n// //object that is returned by \"createContext()\" contains a react component, when we build our own react component, we should actually start with capital Letter\n// //\"createContext()\" also takes in an argument and that argument is the initial value of the context\n// const FavouritesContext = createContext({\n//   favourites: [],\n//   totalFavourites: 0,\n//   addFavourite: (favouriteMeetup) => {},\n//   removeFavourite: (meetupId) => {},\n//   itemIsFavourite: (meetupId) => {},\n// });\n// //it provides the context to all the components that are interested in listenening to the values, and also responsible for updating the context values\n// export function FavouritesContextProvider(props) {\n//   const { userFavourites, setUserFavourites } = useState([]);\n//   //we use \"useState()\", to manage our context data (to update the state), when we manage state inside of the component, the component will execute again and will be reevaluated, that means if we change our context value in the component and pass it to the \"<FavouritesContext.Provider>\", all components which are listening to our context will get updated\n//   /////////////////////////////////////////////////////////////////\n//   function addFavouriteHandler(favouriteMeetup) {\n//     //we should not do it like this, as when working with useState, react does not process state update instantly but schedules them behind the scenes, it still processes them very quickly but not instantly, because of that when we update our state and our state update depends on the latest state snapshot, there is a scenario where the state snapshot does not really reflect the latest state because the last state update wasnt processeed yet, and so we have an alternatative form of calling the state updating function if we depend on the last state snapshot\n//     // setUserFavourites(userFavourites.concat(favouriteMeetup));\n//     //instead of passing the new value to the state update function, we pass a function to the state updating function and that function will be executed for us by react\n//     setUserFavourites((prevUserFavourites) => {\n//       return prevUserFavourites.concat(favouriteMeetup);\n//     });\n//   }\n//   function removeFavouriteHandler(meetupId) {\n//     setUserFavourites((prevUserFavourites) => {\n//       return prevUserFavourites.filter((meetup) => meetup.id !== meetupId);\n//     });\n//   }\n//   function itemIsFavouriteHanlder(meetupId) {\n//     return userFavourites.some((meetup) => meetup.id === meetupId);\n//   }\n//   /////////////////////////////////////////////////////////////////\n//   const context = {\n//     favourites: userFavourites,\n//     totalFavourites: userFavourites.length,\n//     addFavourite: addFavouriteHandler,\n//     removeFavourite: removeFavouriteHandler,\n//     itemIsFavourite: itemIsFavouriteHanlder,\n//   };\n//   return (\n//     <FavouritesContext.Provider value={context}>\n//       {props.children}\n//     </FavouritesContext.Provider>\n//   );\n// }\n// export default FavouritesContext;\nimport { createContext, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FavoritesContext = /*#__PURE__*/createContext({\n  favorites: [],\n  totalFavorites: 0,\n  addFavorite: favoriteMeetup => {},\n  removeFavorite: meetupId => {},\n  itemIsFavorite: meetupId => {}\n});\nexport function FavoritesContextProvider(props) {\n  _s();\n\n  const [userFavorites, setUserFavorites] = useState([]);\n\n  function addFavoriteHandler(favoriteMeetup) {\n    setUserFavorites(prevUserFavorites => {\n      return prevUserFavorites.concat(favoriteMeetup);\n    });\n  }\n\n  function removeFavoriteHandler(meetupId) {\n    setUserFavorites(prevUserFavorites => {\n      return prevUserFavorites.filter(meetup => meetup.id !== meetupId);\n    });\n  }\n\n  function itemIsFavoriteHandler(meetupId) {\n    return userFavorites.some(meetup => meetup.id === meetupId);\n  }\n\n  const context = {\n    favorites: userFavorites,\n    totalFavorites: userFavorites.length,\n    addFavorite: addFavoriteHandler,\n    removeFavorite: removeFavoriteHandler,\n    itemIsFavorite: itemIsFavoriteHandler\n  };\n  return /*#__PURE__*/_jsxDEV(FavoritesContext.Provider, {\n    value: context,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 102,\n    columnNumber: 5\n  }, this);\n}\n\n_s(FavoritesContextProvider, \"UlopS2AxBLjN23/y+OKS+T5dH2M=\");\n\n_c = FavoritesContextProvider;\nexport default FavoritesContext;\n\nvar _c;\n\n$RefreshReg$(_c, \"FavoritesContextProvider\");","map":{"version":3,"names":["createContext","useState","FavoritesContext","favorites","totalFavorites","addFavorite","favoriteMeetup","removeFavorite","meetupId","itemIsFavorite","FavoritesContextProvider","props","userFavorites","setUserFavorites","addFavoriteHandler","prevUserFavorites","concat","removeFavoriteHandler","filter","meetup","id","itemIsFavoriteHandler","some","context","length","children"],"sources":["D:/Resume Projects/Contact-log/src/store/favorites-context.js"],"sourcesContent":["// import { createContext, useState } from 'react';\r\n\r\n// //\"createContext()\" creates a context\r\n\r\n// //context is a JS object, this object created by CreateContext actually contains a react component\r\n\r\n// //object that is returned by \"createContext()\" contains a react component, when we build our own react component, we should actually start with capital Letter\r\n\r\n// //\"createContext()\" also takes in an argument and that argument is the initial value of the context\r\n// const FavouritesContext = createContext({\r\n//   favourites: [],\r\n//   totalFavourites: 0,\r\n//   addFavourite: (favouriteMeetup) => {},\r\n//   removeFavourite: (meetupId) => {},\r\n//   itemIsFavourite: (meetupId) => {},\r\n// });\r\n\r\n// //it provides the context to all the components that are interested in listenening to the values, and also responsible for updating the context values\r\n// export function FavouritesContextProvider(props) {\r\n//   const { userFavourites, setUserFavourites } = useState([]);\r\n//   //we use \"useState()\", to manage our context data (to update the state), when we manage state inside of the component, the component will execute again and will be reevaluated, that means if we change our context value in the component and pass it to the \"<FavouritesContext.Provider>\", all components which are listening to our context will get updated\r\n\r\n//   /////////////////////////////////////////////////////////////////\r\n\r\n//   function addFavouriteHandler(favouriteMeetup) {\r\n//     //we should not do it like this, as when working with useState, react does not process state update instantly but schedules them behind the scenes, it still processes them very quickly but not instantly, because of that when we update our state and our state update depends on the latest state snapshot, there is a scenario where the state snapshot does not really reflect the latest state because the last state update wasnt processeed yet, and so we have an alternatative form of calling the state updating function if we depend on the last state snapshot\r\n//     // setUserFavourites(userFavourites.concat(favouriteMeetup));\r\n//     //instead of passing the new value to the state update function, we pass a function to the state updating function and that function will be executed for us by react\r\n\r\n//     setUserFavourites((prevUserFavourites) => {\r\n//       return prevUserFavourites.concat(favouriteMeetup);\r\n//     });\r\n//   }\r\n\r\n//   function removeFavouriteHandler(meetupId) {\r\n//     setUserFavourites((prevUserFavourites) => {\r\n//       return prevUserFavourites.filter((meetup) => meetup.id !== meetupId);\r\n//     });\r\n//   }\r\n\r\n//   function itemIsFavouriteHanlder(meetupId) {\r\n//     return userFavourites.some((meetup) => meetup.id === meetupId);\r\n//   }\r\n\r\n//   /////////////////////////////////////////////////////////////////\r\n\r\n//   const context = {\r\n//     favourites: userFavourites,\r\n//     totalFavourites: userFavourites.length,\r\n//     addFavourite: addFavouriteHandler,\r\n//     removeFavourite: removeFavouriteHandler,\r\n//     itemIsFavourite: itemIsFavouriteHanlder,\r\n//   };\r\n\r\n//   return (\r\n//     <FavouritesContext.Provider value={context}>\r\n//       {props.children}\r\n//     </FavouritesContext.Provider>\r\n//   );\r\n// }\r\n\r\n// export default FavouritesContext;\r\n\r\nimport { createContext, useState } from 'react';\r\n\r\nconst FavoritesContext = createContext({\r\n  favorites: [],\r\n  totalFavorites: 0,\r\n  addFavorite: (favoriteMeetup) => {},\r\n  removeFavorite: (meetupId) => {},\r\n  itemIsFavorite: (meetupId) => {},\r\n});\r\n\r\nexport function FavoritesContextProvider(props) {\r\n  const [userFavorites, setUserFavorites] = useState([]);\r\n\r\n  function addFavoriteHandler(favoriteMeetup) {\r\n    setUserFavorites((prevUserFavorites) => {\r\n      return prevUserFavorites.concat(favoriteMeetup);\r\n    });\r\n  }\r\n\r\n  function removeFavoriteHandler(meetupId) {\r\n    setUserFavorites((prevUserFavorites) => {\r\n      return prevUserFavorites.filter((meetup) => meetup.id !== meetupId);\r\n    });\r\n  }\r\n\r\n  function itemIsFavoriteHandler(meetupId) {\r\n    return userFavorites.some((meetup) => meetup.id === meetupId);\r\n  }\r\n\r\n  const context = {\r\n    favorites: userFavorites,\r\n    totalFavorites: userFavorites.length,\r\n    addFavorite: addFavoriteHandler,\r\n    removeFavorite: removeFavoriteHandler,\r\n    itemIsFavorite: itemIsFavoriteHandler,\r\n  };\r\n\r\n  return (\r\n    <FavoritesContext.Provider value={context}>\r\n      {props.children}\r\n    </FavoritesContext.Provider>\r\n  );\r\n}\r\n\r\nexport default FavoritesContext;\r\n"],"mappings":";;;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,SAASA,aAAT,EAAwBC,QAAxB,QAAwC,OAAxC;;AAEA,MAAMC,gBAAgB,gBAAGF,aAAa,CAAC;EACrCG,SAAS,EAAE,EAD0B;EAErCC,cAAc,EAAE,CAFqB;EAGrCC,WAAW,EAAGC,cAAD,IAAoB,CAAE,CAHE;EAIrCC,cAAc,EAAGC,QAAD,IAAc,CAAE,CAJK;EAKrCC,cAAc,EAAGD,QAAD,IAAc,CAAE;AALK,CAAD,CAAtC;AAQA,OAAO,SAASE,wBAAT,CAAkCC,KAAlC,EAAyC;EAAA;;EAC9C,MAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCZ,QAAQ,CAAC,EAAD,CAAlD;;EAEA,SAASa,kBAAT,CAA4BR,cAA5B,EAA4C;IAC1CO,gBAAgB,CAAEE,iBAAD,IAAuB;MACtC,OAAOA,iBAAiB,CAACC,MAAlB,CAAyBV,cAAzB,CAAP;IACD,CAFe,CAAhB;EAGD;;EAED,SAASW,qBAAT,CAA+BT,QAA/B,EAAyC;IACvCK,gBAAgB,CAAEE,iBAAD,IAAuB;MACtC,OAAOA,iBAAiB,CAACG,MAAlB,CAA0BC,MAAD,IAAYA,MAAM,CAACC,EAAP,KAAcZ,QAAnD,CAAP;IACD,CAFe,CAAhB;EAGD;;EAED,SAASa,qBAAT,CAA+Bb,QAA/B,EAAyC;IACvC,OAAOI,aAAa,CAACU,IAAd,CAAoBH,MAAD,IAAYA,MAAM,CAACC,EAAP,KAAcZ,QAA7C,CAAP;EACD;;EAED,MAAMe,OAAO,GAAG;IACdpB,SAAS,EAAES,aADG;IAEdR,cAAc,EAAEQ,aAAa,CAACY,MAFhB;IAGdnB,WAAW,EAAES,kBAHC;IAIdP,cAAc,EAAEU,qBAJF;IAKdR,cAAc,EAAEY;EALF,CAAhB;EAQA,oBACE,QAAC,gBAAD,CAAkB,QAAlB;IAA2B,KAAK,EAAEE,OAAlC;IAAA,UACGZ,KAAK,CAACc;EADT;IAAA;IAAA;IAAA;EAAA,QADF;AAKD;;GAhCef,wB;;KAAAA,wB;AAkChB,eAAeR,gBAAf"},"metadata":{},"sourceType":"module"}