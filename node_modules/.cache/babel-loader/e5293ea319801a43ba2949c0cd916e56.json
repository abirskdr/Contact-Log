{"ast":null,"code":"var _jsxFileName = \"D:\\\\Resume Projects\\\\Contact-log\\\\src\\\\pages\\\\AllMeetups.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react'; //the useEffect hook allows us to run some code under certain condiditons\n\nimport MeetupList from '../components/meetups/MeetupList';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction AllMeetupsPage() {\n  _s();\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [loadedMeetups, setLoadedMeetups] = useState([]);\n  useEffect(() => {\n    setIsLoading(true); //this is a good practice, as if whenever this runs again, we set it to true\n\n    fetch('https://react-meetup-e3cd5-default-rtdb.firebaseio.com/meetups.json').then(response => {\n      return response.json();\n    }).then(data => {\n      const meetups = [];\n\n      for (const key in data) {\n        const meetup = {\n          id: key,\n          ...data[key]\n        };\n        meetups.push(meetup);\n      }\n\n      setIsLoading(false); // setLoadedMeetups(data); //setting the data like this is incorrect as we get the data in the form of an object, we dont get an array\n\n      setLoadedMeetups(meetups);\n    });\n  }, []); //useEffect wants two arguments, the first argument is a function, and the second argument is an array of dependencies, without the second argument (without even the empty array), the function in the first argument will get executed whenever the component function is executed\n  //if we just provide an empty array, there are no dependencies, react will only execute this function (in the first argument), when this component function rendered and executed for the first time, and for subsequent executions of this component function, this function (in the first parameter) will not run, as the values of the dependencies (here the empty array {no dependencies}) are always the same (because there are no values)\n  //if we add a dependency, then the function in the first argument runs for the first time (happens always) and runs again for the second time (and times after that) whenever the value of the dependency in the array changes\n  //there is a simple rule, in the dependencies array we should add all external variables, our effect function relies on (state updating functions may be actually an externall dependency as these are constants declared outside the function, but these state updating functions are an exception, react guarantees that these state updating functions never changes {always do the exactly same thing}). In this case there are no external value\n  /////////////////////////////////////////////////////////////////////////////////\n  // fetch('https://react-meetup-e3cd5-default-rtdb.firebaseio.com/meetups.json')\n  //   .then((response) => {\n  //     return response.json();\n  //   })\n  //   .then((data) => {\n  //     setIsLoading(false);\n  //     setLoadedMeetups(data);\n  //     //this causes the component to go into an infinite loop, as each time the setIsLoading and setLoadedMeetups is updated, the whole component is reloaded and updated, while doing so, this component will again send a fetch request to that will again return a promise and that is again calling the setIsLoading and setLoadedMeetups and again reloading the whole component, for this react has a solution using \"useEffect()\"\n  //   });\n  /////////////////////////////////////////////////////////////////////////////////\n\n  if (isLoading) {\n    return /*#__PURE__*/_jsxDEV(\"section\", {\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 55,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 7\n    }, this);\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"section\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"All Meetups\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MeetupList, {\n      meetups: loadedMeetups\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 61,\n    columnNumber: 5\n  }, this);\n}\n\n_s(AllMeetupsPage, \"JeEKF2tZ58/s7PjUTNq9ybMF8W0=\");\n\n_c = AllMeetupsPage;\nexport default AllMeetupsPage;\n\nvar _c;\n\n$RefreshReg$(_c, \"AllMeetupsPage\");","map":{"version":3,"names":["useState","useEffect","MeetupList","AllMeetupsPage","isLoading","setIsLoading","loadedMeetups","setLoadedMeetups","fetch","then","response","json","data","meetups","key","meetup","id","push"],"sources":["D:/Resume Projects/Contact-log/src/pages/AllMeetups.js"],"sourcesContent":["import { useState, useEffect } from 'react'; //the useEffect hook allows us to run some code under certain condiditons\r\n\r\nimport MeetupList from '../components/meetups/MeetupList';\r\n\r\nfunction AllMeetupsPage() {\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [loadedMeetups, setLoadedMeetups] = useState([]);\r\n\r\n  useEffect(() => {\r\n    setIsLoading(true); //this is a good practice, as if whenever this runs again, we set it to true\r\n    fetch('https://react-meetup-e3cd5-default-rtdb.firebaseio.com/meetups.json')\r\n      .then((response) => {\r\n        return response.json();\r\n      })\r\n      .then((data) => {\r\n        const meetups = [];\r\n\r\n        for (const key in data) {\r\n          const meetup = {\r\n            id: key,\r\n            ...data[key],\r\n          };\r\n          meetups.push(meetup);\r\n        }\r\n\r\n        setIsLoading(false);\r\n        // setLoadedMeetups(data); //setting the data like this is incorrect as we get the data in the form of an object, we dont get an array\r\n        setLoadedMeetups(meetups);\r\n      });\r\n  }, []); //useEffect wants two arguments, the first argument is a function, and the second argument is an array of dependencies, without the second argument (without even the empty array), the function in the first argument will get executed whenever the component function is executed\r\n\r\n  //if we just provide an empty array, there are no dependencies, react will only execute this function (in the first argument), when this component function rendered and executed for the first time, and for subsequent executions of this component function, this function (in the first parameter) will not run, as the values of the dependencies (here the empty array {no dependencies}) are always the same (because there are no values)\r\n\r\n  //if we add a dependency, then the function in the first argument runs for the first time (happens always) and runs again for the second time (and times after that) whenever the value of the dependency in the array changes\r\n\r\n  //there is a simple rule, in the dependencies array we should add all external variables, our effect function relies on (state updating functions may be actually an externall dependency as these are constants declared outside the function, but these state updating functions are an exception, react guarantees that these state updating functions never changes {always do the exactly same thing}). In this case there are no external value\r\n\r\n  /////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // fetch('https://react-meetup-e3cd5-default-rtdb.firebaseio.com/meetups.json')\r\n  //   .then((response) => {\r\n  //     return response.json();\r\n  //   })\r\n  //   .then((data) => {\r\n  //     setIsLoading(false);\r\n  //     setLoadedMeetups(data);\r\n  //     //this causes the component to go into an infinite loop, as each time the setIsLoading and setLoadedMeetups is updated, the whole component is reloaded and updated, while doing so, this component will again send a fetch request to that will again return a promise and that is again calling the setIsLoading and setLoadedMeetups and again reloading the whole component, for this react has a solution using \"useEffect()\"\r\n  //   });\r\n\r\n  /////////////////////////////////////////////////////////////////////////////////\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <section>\r\n        <p>Loading...</p>\r\n      </section>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <section>\r\n      <h1>All Meetups</h1>\r\n      <MeetupList meetups={loadedMeetups} />\r\n    </section>\r\n  );\r\n}\r\n\r\nexport default AllMeetupsPage;\r\n"],"mappings":";;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC,C,CAA6C;;AAE7C,OAAOC,UAAP,MAAuB,kCAAvB;;;AAEA,SAASC,cAAT,GAA0B;EAAA;;EACxB,MAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BL,QAAQ,CAAC,IAAD,CAA1C;EACA,MAAM,CAACM,aAAD,EAAgBC,gBAAhB,IAAoCP,QAAQ,CAAC,EAAD,CAAlD;EAEAC,SAAS,CAAC,MAAM;IACdI,YAAY,CAAC,IAAD,CAAZ,CADc,CACM;;IACpBG,KAAK,CAAC,qEAAD,CAAL,CACGC,IADH,CACSC,QAAD,IAAc;MAClB,OAAOA,QAAQ,CAACC,IAAT,EAAP;IACD,CAHH,EAIGF,IAJH,CAISG,IAAD,IAAU;MACd,MAAMC,OAAO,GAAG,EAAhB;;MAEA,KAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;QACtB,MAAMG,MAAM,GAAG;UACbC,EAAE,EAAEF,GADS;UAEb,GAAGF,IAAI,CAACE,GAAD;QAFM,CAAf;QAIAD,OAAO,CAACI,IAAR,CAAaF,MAAb;MACD;;MAEDV,YAAY,CAAC,KAAD,CAAZ,CAXc,CAYd;;MACAE,gBAAgB,CAACM,OAAD,CAAhB;IACD,CAlBH;EAmBD,CArBQ,EAqBN,EArBM,CAAT,CAJwB,CAyBhB;EAER;EAEA;EAEA;EAEA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;;EAEA,IAAIT,SAAJ,EAAe;IACb,oBACE;MAAA,uBACE;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IADF;MAAA;MAAA;MAAA;IAAA,QADF;EAKD;;EAED,oBACE;IAAA,wBACE;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QADF,eAEE,QAAC,UAAD;MAAY,OAAO,EAAEE;IAArB;MAAA;MAAA;MAAA;IAAA,QAFF;EAAA;IAAA;IAAA;IAAA;EAAA,QADF;AAMD;;GA7DQH,c;;KAAAA,c;AA+DT,eAAeA,cAAf"},"metadata":{},"sourceType":"module"}